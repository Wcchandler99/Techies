_task_common: &task_common
  human_input: false
  async_execution: false

html5_game_coding:
  <<: *task_common
  agent: html5_game_architect
  description: >
    Objective: Create a fully functional HTML5 game based on the provided game_hierarchy.xml and game_desc.md files.

    1. Understand Game Requirements:
        - **Review Key Documents:**
            - Thoroughly analyze the `game_hierarchy.xml` and `game_desc.md` files to understand the game's structure, components, and detailed requirements.
        - **Clarify Ambiguities:**
            - If any part of the game design or requirements is unclear, consult with relevant agents or request additional information.

    2. Game Development Tasks:
        - **HTML, CSS, and JavaScript Code:**
            - Write clean, modular, and maintainable HTML5, CSS, and JavaScript code that adheres to the game specifications.
            - Ensure the code is well-documented and follows web development best practices.
        - **Delegation of Tasks:**
            - **Assign Specific Tasks:**
                - Identify and delegate specific components or sections to agents with relevant expertise (e.g., UI design to a UI designer, sound integration to the `html5_game_sound_engineer`).
            - **Communication and Collaboration:**
                - Maintain consistent communication among agents to ensure seamless integration and address any dependencies or issues that arise.

        - **File Management:**
            - Agents should save their work in appropriately named files (e.g., `playerControls.js`, `gameUI.html`).
            - Overwrite the main game file (`game_start.html`) with the latest version of the game, incorporating all completed tasks.

    3. Output Requirements:
        - **Final Deliverables:**
            - Compile all developed components into a cohesive HTML5 game.
            - Ensure the final output is a complete, playable game as specified.
        - **Quality Assurance:**
            - Thoroughly test the game to ensure all components work together seamlessly.
            - Overwrite `game_start.html` with the finalized version, saving all changes.

    **Key Points:**
        - Prioritize collaboration, modular development, and seamless integration.
        - Ensure the game is optimized for performance and compatible across browsers.
  expected_output: >
    A set of HTML5, CSS, and JavaScript files representing a fully functional game.
  output_file: first_task_output.html

html5_game_logic_coding:
  <<: *task_common
  agent: html5_game_architect
  description: >
    Objective: Develop, implement, and integrate the core game logic to ensure seamless gameplay within the HTML5 game framework.

        Initial Setup: Generate Example Gameplay:
            Engage HTML5 Test Designer:
                Before starting the core logic development, use the html5_test_designer agent to generate example gameplay scenarios based on the game specifications. This will create a clear reference for all game logic that needs to be implemented.
                Key Actions:
                    The html5_test_designer should simulate a full gameplay session, covering all essential game mechanics, including grid/board interactions, scoring, progression, collision detection, boundary management, and state transitions.
                    The generated example should be saved and documented, providing a detailed outline of how the game is expected to function.

        Understand the Game Requirements:
            Review Example Gameplay:
                All agents should first review the example gameplay generated by the html5_test_designer to gain a clear understanding of the game's flow, mechanics, and requirements.
            Review Key Documents:
                game_hierarchy.xml: Analyze this file to understand the game's structure and how different components are interconnected.
                game_desc.md: Review this document to grasp the detailed mechanics, rules, and objectives that the game logic must support.
            Word List Integration:
                All word validation logic must use the comprehensive word list from this source to ensure accurate and efficient validation of player inputs.
                Case Insensitivity: Ensure that the validation logic is case insensitive by converting both the player's guess and the words in the list to lowercase before comparison.
                Whitespace Handling: Trim any leading or trailing whitespace from the player’s input and ensure the word list is cleaned similarly when loaded.

        Develop Core Game Logic:
            Grid/Board System:
                Implement the game’s grid or board, ensuring it dynamically updates in response to gameplay events as demonstrated in the example gameplay.
            Core Mechanics:
                Code the fundamental gameplay rules, interactions, and objectives, ensuring they align with the scenarios shown in the example.
            Scoring and Progression:
                Develop a scoring system and progression mechanics that match the example gameplay's logic, rewarding players appropriately based on their actions.
            Collision and Boundary Logic:
                Implement collision detection and boundary management to ensure game elements interact correctly within the play area, as outlined in the example gameplay.
            Game State Management:
                Design and manage transitions between different game states (e.g., start, play, pause, game over), ensuring smooth and intuitive flow as shown in the example.

        Integration and Collaboration:
            Collaborative Development:
                Ensure that the developed logic integrates seamlessly with other game components, following the structure observed in the example gameplay.
            Communication:
                Regularly communicate with other developers to maintain alignment, ensuring that all components work together as expected.

        Output and Documentation:
            Code and Save:
                Save your code in appropriately named files (e.g., gridLogic.js, scoringSystem.js). Ensure that these files are organized and clearly documented.
                Overwrite the main game file (game_start.html) with the integrated logic, incorporating all changes and updates.
            Testing and Refinement:
                Test the game thoroughly, comparing the gameplay to the example generated by the html5_test_designer to ensure consistency. Refine the logic as needed to meet the game specifications.

    Key Points:

        Robust, Efficient Logic: Focus on developing robust, efficient, and bug-free logic that enhances the gameplay experience.
        Modularity and Integration: Ensure that all logic components are modular, making it easier to maintain, debug, and extend the game in the future. Smooth integration with other systems is crucial for a cohesive final product.
  expected_output: >
    Fully functional, production-ready JavaScript files integrated within the HTML5 framework.
  output_file: second_task_output.html


html5_game_testing:
  <<: *task_common
  agent: html5_game_architect
  description: >
    Objective: Test, review, and enhance the game files to ensure they are complete, functional, and adhere to the game specifications.

        Understanding Game Specifications:
            Read the Files:
                Review game_hierarchy.xml and game_desc.md to understand the game structure and requirements.

        Testing the Game:
            Delegate Testing Tasks:
                Assign comprehensive testing tasks to the html5_game_tester.
            Receive Feedback:
                Gather detailed feedback on bugs, issues, and areas needing improvement.
            Word Validation Testing:
                Ensure that the word validation logic correctly utilizes the external word list from this source and that all player inputs are validated accurately.
                Case Insensitivity Testing: Confirm that the validation logic treats words as case insensitive, verifying that inputs like "apple," "Apple," and "APPLE" are all accepted or rejected appropriately.
                Whitespace Handling Testing: Test the validation by inputting words with leading or trailing whitespace and confirm that the system correctly handles these by trimming the whitespace before validation.

        Improving the Game Code:
            Code Review and Enhancement:
                Review and enhance the game based on the tester's feedback.
                Overwrite the main game file (game_fixed.html) after implementing improvements.

        Collaboration and Integration:
            Ensure Cohesion:
                Maintain consistent communication to ensure a cohesive final product.

        Final Deliverables:
            Output Requirements:
                The final deliverables should include fully tested and reviewed HTML, CSS, and JavaScript files.
                Ensure all files reflect the game’s specifications.

    Key Points:

        Comprehensive testing and quality assurance are critical.
        Documentation should explain changes or enhancements.
  expected_output: >
    A fully tested, reviewed, and improved version of the game.
  output_file: test_task_output.txt


html5_game_compilation:
  <<: *task_common
  agent: html5_game_architect
  description: >
    Objective: Compile all game components into a single HTML5 file, creating a fully functional and cohesive game.
    1. Understanding Game Specifications:

        Read the Files:
            Thoroughly understand the game's structure and component relationships from game_hierarchy.xml and game_desc.md.

    2. Compiling the Game:

        Integrate All Code Files:
            Combine all HTML, CSS, and JavaScript files into a single HTML5 file, ensuring all logic, especially word validation using the external word list from [this source](https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt), is correctly integrated. Verify that word validation is case-insensitive and that invalid words are appropriately handled.

        Ensure Complete Functionality:
            The compiled file should represent a complete and playable game.

    3. Delegating Tasks:

        Assign Specific Tasks:
            Assign tasks based on expertise, and ensure consistency in code integration.

    4. Review and Refinement:

        Delegate Final Review:
            Have the html5_game_reviewer review the compiled HTML5 file.
        Implement Feedback:
            Refine the game based on feedback, ensuring all components are correctly integrated.

    5. Output Requirements:

        Final HTML5 Game File:
            The final output should be a single HTML5 file that incorporates all game components.
        Quality Assurance:
            Ensure the game is bug-free, fully functional, and provides a seamless user experience.

    **Key Points:**
        - Ensure all components work harmoniously.
        - The final game should undergo rigorous testing and review.
  expected_output: >
    A single HTML5 file that includes all the game components, fully integrated and functional.
  output_file: compilation_task_output.html


html5_test_coding:
  <<: *task_common
  agent: html5_test_architect
  description: >
    Objective: Design and execute unit tests for the game to verify that all functionalities are working correctly, and identify any issues or bugs that need to be addressed.

    1. Understanding Game Requirements:
        - Read the Files:
            - Read game_hierarchy.xml and the game specifications to thoroughly understand the game’s hierarchy, structure, and detailed functionalities that need to be tested.
            - Read game_desc.md to grasp the detailed game specifications, mechanics, and functional requirements.
        - Identify Functional Aspects:
            - Create a comprehensive list of all functional aspects of the game that must be tested, including game mechanics, user interactions, animations, scoring, and any other critical features.

    2. Designing Test Scenarios:
        - Delegate Gameplay Design:
            - Assign the task of designing example gameplay scenarios to the html5_test_designer. These scenarios should cover various aspects of the game to thoroughly test its functionality and edge cases.
        - Set Up Testing Environment:
            - Delegate the task of setting up the game code for testing to the html5_test_setup_engineer. This setup should include all necessary configurations, environments, and any mock data needed to run the tests effectively.

    3. Executing Unit Tests:
        - Conduct Tests:
            - Delegate the task of conducting the unit tests to the html5_test_engineer. The html5_test_engineer should run all designed test cases and document the outcomes.
        - Ensure Comprehensive Coverage:
            - Ensure that the unit tests cover all aspects listed in the functional aspects document, testing both typical user interactions and edge cases to identify any potential bugs or performance issues.

    4. Reporting Results:
        - Create a Test Report:
            - Compile a detailed test report indicating all working and non-working aspects of the game. The report should categorize issues by severity, outline steps to reproduce any bugs, and suggest potential fixes.
        - Document Findings:
            - The report should also include a summary of all tests performed, the results of each test (pass/fail), and any observations that might be relevant for further development or optimization.

    5. Final Deliverables:
        - Comprehensive Unit Test Suite:
            - Provide a complete suite of unit tests for the game, including all test scripts, test data, and any necessary instructions for running the tests.
        - Test Report:
            - Submit a detailed test report that summarizes the outcomes of all tests, clearly indicating which game functionalities are working as intended and which are not.

    Key Points for Completion:
        - Thorough Testing: Ensure all game functionalities are thoroughly tested, covering both normal and edge cases.
        - Clear Documentation: Provide detailed documentation for each test case and ensure the test report clearly communicates any issues found.
        - Collaboration and Communication: Maintain open communication among agents to ensure smooth execution of tests and timely resolution of any issues discovered.
  expected_output: >
    A comprehensive unit test report for the HTML5 game, accompanied by a full suite of unit tests, ensuring that all game functionalities are thoroughly verified, documented, and optimized for further development.
  output_file: unit_test_results.txt

html5_game_final:
  <<: *task_common
  agent: html5_test_architect
  description: >
    Objective: Improve the HTML5 game code based on test results and produce a final, fully functional HTML5 game file.

    Instructions for Agents:

        1. Understanding the Current State of the Game:
            - Game Hierarchy and Specifications: Read and thoroughly understand the game hierarchy from game_hierarchy.xml and the game specifications from game_desc.md. Ensure that you are familiar with the entire structure, mechanics, and intended functionalities of the game.
            - Review Test Results: Analyze the contents of test_results.txt to identify any bugs, performance issues, or incomplete functionalities. Pay attention to failed tests, edge cases, and areas needing improvement.

        2. Code Improvement and Assignment of Tasks:
            - Analyze Test Failures: Identify the specific parts of the game code that need to be improved based on the test results. Prioritize fixing critical issues, addressing broken functionality, and ensuring that edge cases are properly handled.
            - Delegate to Agents: Assign specific coding tasks to the most appropriate agents based on their expertise. Ensure that each agent is working on a distinct part of the game to maximize efficiency and avoid overlapping efforts:
                - Delegate gameplay logic to agents skilled in handling mechanics.
                - Assign user interface and animation improvements to agents specializing in design and interaction.
                - For general coding and coordination tasks, assign them to the html5_game_engineer agent.
            - Refer to Existing Components: Ensure that agents consistently reference existing components in the code. Agents should reuse or adapt these components when possible. If a necessary component does not already exist, either create it directly or delegate the task to an agent best suited for the task.

        3. Code Integration and Collaboration:
            - Collaborative Development: Agents must be aware of their coworkers' work to ensure smooth integration of the code. Communicate and collaborate where necessary to avoid conflicts or duplication of code.
            - Code Overwriting: Agents should overwrite their assigned sections of the code with new, improved versions. Ensure that all bugs, broken functionality, and edge cases identified in the test results are addressed in the updated code.
            - Component Creation: If a new component is needed that doesn't currently exist in the code, the responsible agent should create it. If the task requires specialized knowledge, delegate the creation of the component to the appropriate agent.

        4. Final Output:
            - Single HTML5 File: Once all code improvements have been implemented, consolidate the entire game code into a single HTML5 file. This file should contain all scripts, styles, assets, and functionalities required to run the game seamlessly.
            - Ensure Functionality: Before submitting the final file, ensure that the entire game works correctly, including all functionalities, interactions, animations, and scoring mechanics. Perform a final round of testing to verify that the game operates as expected without errors.

    Key Points for Completion:
        - Fix all identified issues from the test results.
        - Ensure collaborative development to integrate code seamlessly.
        - Produce a clean, well-organized HTML5 file that includes all necessary components and scripts for the game to run correctly.
  expected_output: >
    A fully functional and optimized HTML5 game in the form of a single .html file. This file should integrate all improvements and reflect the test results and the hierarchical structure of the game.
  output_file: game_final.html
# vim: set foldmethod=indent foldlevel=0: